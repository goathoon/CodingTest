 ///////////////////////////////// 정렬 ////////////////////////////////////////////////
완전탐색 기준??
떠올리는거 그대로 하되, 시간복잡도 먼저 계산한 후, constraint 따짐.

ex. 시간복잡도가 n^2일 경우 n이 10^4 까지 된다. 그럼 10^8 ~ 대략 1억.
시간제한에 걸릴 수도 있다. 
nlogn or n, logn 의 알고리즘이 없을까?

-- two sum
quick sort로 정렬을 하고 
양 끝에서부터 더한값과 target값을 비교하며, 인덱스 변경.
그러면 원소를 한번씩만 방문하게 되어, 완전탐색의 n^2시간복잡도 보다 좋은
nlogn(정렬) + n(탑색)이 된다. 따라서 O(nlogn) 완전탐색보다 훨씬빠름.

-- 완주하지 못한 선수
완전탐색은 10^5 의 input이므로, 하게되면 10^10이므로 시간초과가 날 것임.
n이 10^6 10^7일 경우, 정렬조차 못한다. O(n)으로 해야겠다.

정렬조차 못할 경우는 제약조건만 보고도 알 수 있다.
정렬 두번 O(nlogn)
으로 하고, 반복문 하나로 일대일대응.
nlogn * 2 + n의 시간복잡도.

///////////////////////////////////// 스택 ///////////////////////////////////////
-- 주식가격 [1,2,3,2,3]
1,2,3,2,3
1,2,3,2 pop 3 // 3idx  =1
1,2,2(4)
1,2,2(4),3(5)
pop (5) = 0
1,2,2(4)
pop(2) = 5-4 = 1 //1,2
pop(2) = 5-2 = 3 //1
pop(1) = 5- 1 =4 //empty
############# 좋은 방법 #############
1
1,2 (1과 2 크기 비교)
1,2,3(2와 3 크기 비교)
1,2,3,2 (2가 3보다 작으므로 3 pop하고 2 push) 1 입력
1,2,2,3 (2와 3 크기 비교)

if [1,2,3,1,2]
1,2,3,1 pop3 = 3인덱스에 1
1,2,1 pop 2 = 2인덱스에 2
1,1
1,1,2
따라서 [4,3,1,1,0]

##스택 -> 순회하며 문제를 해결할 수 있다.
price의 길이가 아무리 길더라도, 한번만 순회하며 문제 해결.
복잡도 O(n)


//////////////////////////// Hash Table /////////////////////////////
면접 필수 질문.
해시 테이블의 시간 복잡도.
메모리를 사용하면서 시간복잡도를 높힌다.
검색 O(1)
-- two sum 을 또다시? O(n)으로 할 수 있다.
//[2,7,11,15]
[2,3,5,8,11,19]
target = 14

i = 0 부터 len까지 반복하며
2를 만나면 hashmap[14-2(필요한 숫자)] = 0 (index값 저장)
3을 만나면 hashmap[14-3] = 1(3의 index)
5를 만나면 hashmap[14-5] = 2(5의 index)
.
.
.
11을 만나면 11을 넣는순간 hashmap[11] 을 만나서 값 도출 가능.

-- 완주하지 못한 선수도 마찬가지로 해쉬테이블로 사용 가능



/////////////////////////////// 재귀 //////////////////////////////////////
피보나치 시간복잡도
fibo(n) = fibo(n-1) + fibo(n-2) -> 함수 한번 호출 때마다
2개의 함수를 다시호출 이를 n개하므로 
시간복잡도 O(2^n)

*세개의 함수 즉 ,F(N) = F(N-1) + F(N-2) + F(N-3) 이라면 
시간복잡도 O(3^n)

* f(n) = n + f(n-1) 이라면 시간복잡도 O(n)

--Climbing Stairs
CS(4) = CS(2) + CS(3)
4칸 올라가는 방법 = 2칸올라가는 방법 + 3칸 올라가는 방법
1,1,1//1 CS(3)
2,1//1 CS(3)
1,2,//1 CS(3)
1,1,//2 CS(2)
2,//2 CS(2)
이런식으로 나눈거임 
n이 45라면,
2^45라서, 10^15로 시간초과가 날 수밖에없다. ->DP로 해결


//////////////////////////// DP ///////////////////////////////////
recursive sum 은 
rs(10)
rs(9)
rs(8)
.
.
rs(1) 까지 중복이 안되므로 DP로 하지 못한다.
하지만, Climbing Stairs 와 같이
CS(5) = CS(4) + CS (3)
	= CS(3) + CS(2) + CS(3)
과 같이 CS(3)이 중복되는 경우 DP를 활용해 볼 수 있다.
중복되는 값들을 Hash Map 같은것으로 활용하요 중복되는
함수값들을 저장하여 꺼내씀.
그러면 중복함수사용을 막기 떄문에,
시간복잡도는 O(n)이 된다.


#### 구현방법 두 가지
1. Top Down(Memoization)

2.Bottom Up(Tabulation)
배열을 하나씩 채워나간다는 느낌.
f(n) 이라면 총 n번 시행하므로 시간복잡도는 O(n)이다.


/////////////////////////////// BFS / DFS /////////////////////////////////
최단거리 문제는 BFS가 효과적이다.